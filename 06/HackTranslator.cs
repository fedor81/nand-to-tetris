using System.Collections.Generic; using System.Linq; using System; using System.Net.Sockets;  namespace Assembler {     public class HackTranslator     {         private int VariableCounter = 16;          /// <summary>         /// Транслирует инструкции ассемблерного кода (без меток) в бинарное представление.         /// </summary>         /// <param name="instructions">Ассемблерный код без меток</param>         /// <param name="symbolTable">Таблица символов</param>         /// <returns>Строки инструкций в бинарном формате</returns>         /// <exception cref="FormatException">Ошибка трансляции</exception>         public string[] TranslateAsmToHack(string[] instructions, Dictionary<string, int> symbolTable)         {             var result = new string[instructions.Length];              for (int i = 0; i < instructions.Length; i++)                 result[i] = instructions[i].StartsWith('@')                     ? AInstructionToCode(instructions[i], symbolTable)                     : CInstructionToCode(instructions[i]);              return result;         }          /// <summary>         /// Транслирует одну A-инструкцию ассемблерного кода в бинарное представление         /// </summary>         /// <param name="aInstruction">Ассемблерная A-инструкция, например, @42 или @SCREEN</param>         /// <param name="symbolTable">Таблица символов</param>         /// <returns>Строка, содержащее нули и единицы — бинарное представление ассемблерной инструкции, например, "0000000000000101"</returns>         public string AInstructionToCode(string aInstruction, Dictionary<string, int> symbolTable)         {             int addressInDecimal;             var address = aInstruction[1..];              if (char.IsDigit(aInstruction[1]))                 addressInDecimal = int.Parse(address);             else             {                 if (!symbolTable.ContainsKey(address))                     symbolTable.Add(address, VariableCounter++);                  addressInDecimal = symbolTable[address];             }              // Перевод в двоичный формат             var addressInBin = Convert.ToString(addressInDecimal, 2).PadLeft(15, '0');              return "0" + addressInBin;         }          /// <summary>         /// Транслирует одну C-инструкцию ассемблерного кода в бинарное представление         /// </summary>         /// <param name="cInstruction">Ассемблерная C-инструкция, например, A=D+M</param>         /// <returns>Строка, содержащее нули и единицы — бинарное представление ассемблерной инструкции, например, "1111000010100000"</returns>         public string CInstructionToCode(string cInstruction)         {             var instructionAndJump = cInstruction.Split(';');             var compAndDest = instructionAndJump[0].Split('=');              // Определяем переход             var jump = instructionAndJump.Length == 1 ? "000" : JumpInstructions[instructionAndJump[1]];              var destination = "";             string competition;              if (compAndDest.Length == 1)             {                 destination = "000";                 competition = compAndDest[0];             }             else             {                 competition = compAndDest[1];                  foreach (var register in "ADM")                     destination += compAndDest[0].Contains(register) ? "1" : "0";             }              // Определене вычисляемого выражения             string useMRegister = competition.Contains('M') ? "1" : "0";             string compDictKey = competition.Replace("A", "R").Replace("M", "R");             competition = CompInstructions[compDictKey];              return "111" + useMRegister + competition + destination + jump;         }          private static readonly Dictionary<string, string> JumpInstructions = new()         {             { "JGT", "001" },             { "JEQ", "010" },             { "JGE", "011" },             { "JLT", "100" },             { "JNE", "101" },             { "JLE", "110" },             { "JMP", "111" },         };          private static readonly Dictionary<string, string> CompInstructions = new()         {             { "0", "101010"},   // Буквой R обозначил регистр A или M             { "1", "111111"},             { "-1", "111010"},             { "D", "001100"},             { "R", "110000"},             { "!D", "001101"},             { "!R", "110001"},             { "-D", "001111"},             { "-R", "110011"},             { "D+1", "011111"},             { "R+1", "110111"},             { "D-1", "001110"},             { "R-1", "110010"},             { "D+R", "000010"},             { "D-R", "010011"},             { "R-D", "000111"},             { "D&R", "000000"},             { "D|R", "010101"}         };     } } 